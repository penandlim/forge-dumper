// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import { Vm } from "forge-std/Vm.sol";
import { stdJson } from "forge-std/StdJson.sol";

/// @title ForgeDumper
/// @author penandlim (@weeb_mcgee)
/// @notice A library to dump blockchain state into a JSON file compatible with Anvil's `anvil_loadState`.
/// @dev This library facilitates state dumping for testing purposes. It's recommended to dump an initial state
/// in `setUp()` and use it as a base for subsequent dumps in individual tests. The output format
/// matches Anvil's state dump structure.
library ForgeDumper {
    using stdJson for string;
    // Cheat code address, 0x7109709ECfa91a80626fF3989D68f67F5b1DD12D.
    Vm internal constant vm = Vm(address(uint160(uint256(keccak256("hevm cheat code")))));

    /// @notice Indicates that a specified file path does not exist.
    /// @param path The file path that was not found.
    error ForgeDumper__PathDoesNotExist(string path);
    /// @notice Indicates that a specified JSON key does not exist in the target JSON string.
    /// @param key The JSON key that was not found.
    error ForgeDumper__KeyDoesNotExist(string key);
    /// @notice Indicates that the input JSON file is not in the expected format.
    error ForgeDumper__InvalidFormat();

    /// @notice Dumps the current blockchain state to the specified file path.
    /// @dev If the path includes directories, they will be created recursively. The dumped state is
    /// formatted to be Anvil-compatible.
    /// @param path The file path where the state dump will be saved.
    function dumpState(string memory path) internal {
        if (vm.contains(path, "/")) {
            string memory dirPath;
            string[] memory splitPath = vm.split(path, "/");
            for (uint256 i = 0; i < splitPath.length - 1; i++) {
                dirPath = string.concat(dirPath, splitPath[i], "/");
            }
            vm.createDir(dirPath, true);
        }
        vm.dumpState(path);
        // Then format the file in path into anvil state dump format
        formatState(path);
    }

    /// @notice Dumps the current blockchain state to a new file, merging it with a base state.
    /// @dev The state from `basePath` is used as a foundation. The current state is dumped to `path`,
    /// formatted, and then merged with the base state. If `basePath` does not exist, the function reverts.
    /// Values from the current state dump (new `path`) will overwrite those in the `basePath` during the merge.
    /// @param basePath The file path of the base state dump.
    /// @param path The file path where the new, merged state dump will be saved.
    function dumpState(string memory basePath, string memory path) internal {
        // First check if the basePath exists
        if (!vm.exists(basePath)) {
            revert ForgeDumper__PathDoesNotExist(basePath);
        }
        // Then dump the state into path
        vm.dumpState(path);

        // Then format the file in path into anvil state dump format
        formatState(path);

        // Then merge the new state into the base state, overwriting any existing keys
        string memory mergedState = mergeStates(basePath, path);
        mergedState.write(path);
    }

    /// @notice Formats a Forge state dump file into the Anvil `anvil_loadState` compatible format.
    /// @dev Converts a state dump generated by `vm.dumpState()` (Forge's format) into the structure
    /// required by Anvil. This includes transforming hex nonces to decimals and adding necessary block
    /// information. If the file at `path` already appears to be in Anvil format (contains an 'accounts'
    /// key at the root), the function returns early. The schema transformation is detailed below:
    /// Forge's `dumpState` output (simplified):
    /// ```json
    /// {
    ///     "0xaddress": {
    ///         "nonce": "0x hexadecimal nonce",
    ///         "balance": "0x...",
    ///         "code": "0x...",
    ///         "storage": { "0xslot": "0xvalue" }
    ///     }
    /// }
    /// ```
    /// Anvil's `loadState` input:
    /// ```json
    /// {
    ///     "accounts": {
    ///         "0xaddress": {
    ///             "nonce": decimal_nonce, // Note: decimal
    ///             "balance": "0x...",
    ///             "code": "0x...",
    ///             "storage": { "0xslot": "0xvalue" }
    ///         }
    ///     },
    ///     "block": {
    ///         "number": "0x1565696",
    ///         "coinbase": "0x0000000000000000000000000000000000000000",
    ///         "timestamp": "0x681c048b",
    ///         "gas_limit": "0x2255100",
    ///         "basefee": "0x8c9157b9",
    ///         "difficulty": "0x65863990937bd52c0235fcec1cc5ff429e52b143236f3bc804601b6e5db9100d",
    ///         "prevrandao": "0x65863990937bd52c0235fcec1cc5ff429e52b143236f3bc804601b6e5db9100d",
    ///         "blob_excess_gas_and_price": {
    ///             "excess_blob_gas": 0,
    ///             "blob_gasprice": 1
    ///         }
    ///     },
    ///     "best_block_number": "0x1565696",
    ///     "blocks": [],
    ///     "transactions": [],
    ///     "historical_states": null
    /// }
    /// ```
    /// @param path The file path of the state dump to format.
    function formatState(string memory path) internal {
        // First read the file in path
        // We will be using file as the internal key for serialization
        string memory file = vm.readFile(path);

        // Check if the file is in forge cheatcode dump format
        // If it is, then we need to convert it to anvil format

        // If it has the accounts key, then its probably already in anvil format
        // TODO: Make this robust and ensure nonce is converted to decimal and block key is added
        if (file.keyExists(".accounts")) {
            return;
        }
        
        // The file is in forge cheatcode dump format
        // First lets ensure that every key (address) has a decimal nonce
        // Convert hex nonces to decimal
        // Find all keys in the file
        string[] memory accounts = vm.parseJsonKeys(file, "$");
        string memory accountsKey = string.concat(file,".accounts");
        string memory result = "{}";
        for (uint256 i = 0; i < accounts.length; i++) {
            string memory account = accounts[i];
            string memory accountKey = string.concat(accountsKey,".",account);
            accountKey.serialize("nonce", vm.parseUint(file.readString(string.concat(".",account,".nonce"))));
            accountKey.serialize("balance", file.readString(string.concat(".",account,".balance")));
            accountKey.serialize("code", file.readString(string.concat(".",account,".code")));
            string[] memory storageSlots = vm.parseJsonKeys(file, string.concat(".",account,".storage"));
            string memory storageKey = string.concat(accountKey,".storage");
            string memory storageJson = "{}";
            for (uint256 j = 0; j < storageSlots.length; j++) {
                string memory storageSlot = storageSlots[j];
                string memory storageValue = file.readString(string.concat(".",account,".storage.",storageSlot));
                storageJson = storageKey.serialize(storageSlot, storageValue);
            }
            result = accountKey.serialize("storage", storageJson);
            result = accountsKey.serialize(account, result);
        }
        file.serialize("accounts", result);

        // Block
        string memory blockKey = string.concat(file,".block");
        vm.serializeUintToHex(blockKey, "number", vm.getBlockNumber());
        vm.serializeAddress(blockKey, "coinbase", block.coinbase);
        vm.serializeUintToHex(blockKey, "timestamp", vm.getBlockTimestamp());
        vm.serializeUintToHex(blockKey, "gas_limit", block.gaslimit);
        vm.serializeUintToHex(blockKey, "basefee", block.basefee);
        vm.serializeBytes32(blockKey, "difficulty", bytes32(block.difficulty));
        string memory blobExcessGasAndPriceKey = string.concat(blockKey,".blob_excess_gas_and_price");
        vm.serializeUint(blobExcessGasAndPriceKey, "excess_blob_gas", 0); // TODO: Verify this
        string memory blobData = vm.serializeUint(blobExcessGasAndPriceKey, "blob_gasprice", vm.getBlobBaseFee());
        vm.serializeString(blockKey, "blob_excess_gas_and_price", blobData);
        string memory blockData = vm.serializeBytes32(blockKey, "prevrandao", bytes32(block.prevrandao));
        file.serialize("block", blockData);

        string memory formattedFile = vm.serializeUintToHex(file, "best_block_number", block.number);

        // TODO: Add blocks,transactions,historical_states if this is retrievable from within forge test

        // Write the formatted JSON back to the file
        formattedFile.write(string.concat(path));
    }

    /// @notice Merges two Anvil-formatted state dump files.
    /// @dev Combines the state from `basePath` and `newPath`. If an account or storage slot exists in both,
    /// the value from `newPath` takes precedence. The merged state is returned as a JSON string.
    /// Both input files must exist and be in the Anvil state dump format.
    /// @param basePath File path of the base state dump (Anvil format).
    /// @param newPath File path of the new state dump to merge (Anvil format).
    /// @return mergedStateJson A JSON string representing the merged state.
    function mergeStates(string memory basePath, string memory newPath) internal returns (string memory) {
        // ---------------------------------------------------------------------
        // 0. Read both files (they are guaranteed to exist)
        // ---------------------------------------------------------------------
        string memory baseFile = vm.readFile(basePath);
        string memory newFile  = vm.readFile(newPath);

        // This is the root object we will serialise everything into.
        string memory rootKey      = string.concat(basePath,"_", newPath,"_merged_state");

        // ---------------------------------------------------------------------
        // 1. ACCOUNTS  ---------------------------------------------------------
        // ---------------------------------------------------------------------
        string memory accountsKey  = string.concat(rootKey, ".accounts");
        string memory accountsJson = "{}";

        // --- 1a. Process every account that appears in *new* (overwrite first)
        string[] memory newAccounts = vm.parseJsonKeys(newFile, ".accounts");
        for (uint256 i = 0; i < newAccounts.length; i++) {
            string memory addr         = newAccounts[i];
            string memory mergedAccObj = _mergeAccount(baseFile, newFile, addr);
            accountsJson               = accountsKey.serialize(addr, mergedAccObj);
        }

        // --- 1b. Add any account that exists only in *base*
        string[] memory baseAccounts = vm.parseJsonKeys(baseFile, ".accounts");
        for (uint256 i = 0; i < baseAccounts.length; i++) {
            string memory addr = baseAccounts[i];
            if (!newFile.keyExists(string.concat(".accounts.", addr))) {
                string memory mergedAccObj = _mergeAccount(baseFile, newFile, addr);
                accountsJson               = accountsKey.serialize(addr, mergedAccObj);
            }
        }

        // ---------------------------------------------------------------------
        // 2. TOP-LEVEL KEYS  ---------------------------------------------------
        // ---------------------------------------------------------------------
        rootKey.serialize("accounts", accountsJson);


        // Block
        string memory blockKey = string.concat(rootKey,".block");
        vm.serializeUintToHex(blockKey, "number", newFile.readUint(".block.number"));
        vm.serializeAddress(blockKey, "coinbase", newFile.readAddress(".block.coinbase"));
        vm.serializeUintToHex(blockKey, "timestamp", newFile.readUint(".block.timestamp"));
        vm.serializeUintToHex(blockKey, "gas_limit", newFile.readUint(".block.gas_limit"));
        vm.serializeUintToHex(blockKey, "basefee", newFile.readUint(".block.basefee"));
        vm.serializeBytes32(blockKey, "difficulty", newFile.readBytes32(".block.difficulty"));
        string memory blobExcessGasAndPriceKey = string.concat(blockKey,".blob_excess_gas_and_price");
        vm.serializeUint(blobExcessGasAndPriceKey, "excess_blob_gas", newFile.readUint(".block.blob_excess_gas_and_price.excess_blob_gas"));
        string memory blobData = vm.serializeUint(blobExcessGasAndPriceKey, "blob_gasprice", newFile.readUint(".block.blob_excess_gas_and_price.blob_gasprice"));
        vm.serializeString(blockKey, "blob_excess_gas_and_price", blobData);
        string memory blockData = vm.serializeBytes32(blockKey, "prevrandao", newFile.readBytes32(".block.prevrandao"));
        rootKey.serialize("block", blockData);

        string memory rootJson = vm.serializeUintToHex(rootKey, "best_block_number", newFile.readUint(".block.number"));

        return rootJson;
    }

    /// -----------------------------------------------------------------------
    /// INTERNAL HELPERS
    /// -----------------------------------------------------------------------

    /// @dev Internal helper to deeply merge account data, including storage, from two state JSON strings.
    /// Values from `newFile` overwrite `baseFile` for the specified address `addr`.
    /// The function assumes `baseFile` and `newFile` are JSON strings representing Anvil-formatted state dumps.
    /// @param baseFile JSON string of the base state.
    /// @param newFile JSON string of the new state to merge.
    /// @param addr The account address to merge.
    /// @return accountJson A JSON string representing the merged account data for `addr`.
    function _mergeAccount(
        string memory baseFile,
        string memory newFile,
        string memory addr
    ) private returns (string memory) {
        string memory tmpAccKey  = string.concat(addr, "tmp_account");
        string memory path       = string.concat(".accounts.", addr);

        // ---------- basic fields --------------------------------------------
        string[3] memory fields = ["nonce", "balance", "code"];
        for (uint256 i = 0; i < fields.length; i++) {
            string memory fPath = string.concat(path, ".", fields[i]);
            if (i == 0) { // nonce field
                uint256 nonceVal = newFile.keyExists(fPath)
                    ? newFile.readUint(fPath)
                    : baseFile.readUint(fPath);
                tmpAccKey.serialize(fields[i], nonceVal);
            } else {
                string memory val = newFile.keyExists(fPath)
                    ? newFile.readString(fPath)
                    : baseFile.readString(fPath);
                tmpAccKey.serialize(fields[i], val);
            }
        }

        // ---------- storage --------------------------------------------------
        string memory storageKey  = string.concat(tmpAccKey,".storage");
        string memory storageJson = "{}";

        // first copy everything from *base* …
        if (baseFile.keyExists(string.concat(path, ".storage"))) {
            string[] memory baseSlots =
                vm.parseJsonKeys(baseFile, string.concat(path, ".storage"));
            for (uint256 j = 0; j < baseSlots.length; j++) {
                string memory slot  = baseSlots[j];
                string memory value =
                    baseFile.readString(string.concat(path, ".storage.", slot));
                storageJson         = storageKey.serialize(slot, value);
            }
        }

        // … then overwrite / add from *new*
        if (newFile.keyExists(string.concat(path, ".storage"))) {
            string[] memory newSlots =
                vm.parseJsonKeys(newFile, string.concat(path, ".storage"));
            for (uint256 j = 0; j < newSlots.length; j++) {
                string memory slot  = newSlots[j];
                string memory value =
                    newFile.readString(string.concat(path, ".storage.", slot));
                storageJson         = storageKey.serialize(slot, value);
            }
        }

        // attach the (possibly empty) storage object and return the account
        return tmpAccKey.serialize("storage", storageJson);
    }
}
